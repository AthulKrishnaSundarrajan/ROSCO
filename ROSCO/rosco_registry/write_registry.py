import yaml
import ROSCO_toolbox
import os
from ROSCO_toolbox.ofTools.util.FileTools import load_yaml

def write_registry(yfile):
    reg = load_yaml(yfile)
    reg.pop('default_types')
    registry_fname = os.path.join(os.path.dirname(os.path.dirname(os.path.abspath(__file__))),'src','ROSCO_Types.f90')
    file = open(registry_fname, 'w')
    file.write('! ROSCO Registry\n')
    file.write('! This file is automatically generated by write_registry.py using ROSCO v{}\n'.format(ROSCO_toolbox.__version__))
    file.write('! For any modification to the registry, please edit the rosco_types.yaml accordingly\n \n')
    file.write('MODULE ROSCO_Types\n') 
    file.write('USE, INTRINSIC :: ISO_C_Binding\n')
    file.write('IMPLICIT NONE\n')
    file.write('\n')
    for toptype in reg.keys():
        file.write('TYPE, PUBLIC :: {}\n'.format(toptype))
        for attype in reg[toptype].keys():
            f90type = read_type(reg[toptype][attype])
            atstr  =  check_size(reg[toptype], attype)
            if reg[toptype][attype]['equals']:
                atstr += ' = ' + reg[toptype][attype]['equals']
            file.write('    {:<25s}     :: {:<25s}   ! {}\n'.format(f90type, atstr, reg[toptype][attype]['description']))
        file.write('END TYPE {}\n'.format(toptype))
        file.write('\n')
    file.write('END MODULE ROSCO_Types')
    file.close()

def check_size(main_attribute, sub_attribute):
    if main_attribute[sub_attribute]['type'] == 'derived_type':
        atstr = sub_attribute
    else:
        size = int(main_attribute[sub_attribute]['size'])
        if size == 0:
            atstr = sub_attribute
        else:
            atstr = sub_attribute + '({})'.format(size)
    return atstr

def read_type(param):
    if param['type'] == 'integer':
        f90type = 'INTEGER(4)'
        if param['allocatable']:
            f90type += ', DIMENSION(:), ALLOCATABLE'
    elif param['type'] == 'real':
        f90type = 'REAL(8)'
        if param['allocatable']:
            if param['dimension']:
                f90type += ', DIMENSION{}, ALLOCATABLE'.format(param['dimension'])
            else:
                f90type += ', DIMENSION(:), ALLOCATABLE'
        elif param['dimension']:
            f90type += ', DIMENSION{}'.format(param['dimension'])
    elif param['type'] == 'character':
        f90type = 'CHARACTER'
        if param['length']:
            f90type += '({})'.format(param['length'])
        if param['allocatable']:
            if param['dimension']:
                f90type += ', DIMENSION{}, ALLOCATABLE'.format(param['dimension'])
            else:
                f90type = 'CHARACTER(:), ALLOCATABLE'
    elif param['type'] == 'logical':
        f90type = 'LOGICAL'
    elif param['type'] == 'c_integer':
        f90type = 'INTEGER(C_INT)'
    elif param['type'] == 'c_pointer':
        f90type = 'TYPE(C_PTR)'
    elif param['type'] == 'c_intptr_t':
        f90type = 'INTEGER(C_INTPTR_T)'
    elif param['type'] == 'c_funptr':
        f90type = 'TYPE(C_FUNPTR)'
    elif param['type'] == 'derived_type':
        f90type = 'TYPE({})'.format(param['id'])
    else:
        raise AttributeError('{} does not have a recognizable type'.format(param['type']))


    return f90type

if __name__ == '__main__':
    fname = os.path.join(os.path.dirname(os.path.abspath(__file__)),'rosco_types.yaml')
    write_registry(fname)

